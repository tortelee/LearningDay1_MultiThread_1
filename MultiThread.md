# Java concurrency
### concurrence model
#### 知识点
- 线程安全
- 线程封闭
- 线程调度
- 同步容器
- 并发容器
- AQS
- J.U.C
- etc
#### 该高并发解决思路与手段
- 扩容
- 缓存
- 列队
- 拆分
- 服务器降级与熔断
- 数据库切库
- 分库分表
- etc
#### 课程讲解顺序
- 并发，高并发相关概念
- CPU 多级缓存，缓存一致性，乱序执行
- java内存模型
- 并发优势与风险
- 并发模拟（postman, jmeter,代码）

### 1-3
##### CountExample
`ExecutorService` 
- 位于java.util.concurrence
- Interface
- 一个Executor, 提过方法来管理终端和方法，可以产生Feature为跟踪yige
或多个异步任务执行。一个ExecutorService可以关闭，这将导致它拒绝新的任务。提供两种办法来关闭。
  - shutdownNow() 直接终止
  - shutdown() 允许先前的任务继续执行
    
执行任务，`invokeAll()`,执行task 返回持有他们的状态和结果的所有完成期货列表。

`Semaphore`
- java.util.concurrency
- 一个信号计数量。在概念上，信号量维持一组许可证。如果有必要，每个 `acquire()`都会阻塞，
直到许可证可用，然后才能使用它。每个 `release()` 添加许可证，潜在地释放阻塞获取方。
  但是实际上没有使用实际许可证对象；Semaphore只保留可用数量的计数，并相应的执行。
  
### 1-4 
##### 并发
同时拥有两个或者多个线程，如果程序在单核处理器上运行，多个线程交替地换入和换出内存，
这些线程是同时存在的，每个线程都处于执行过程中的某个状态，如果运行在多核处理器上，此时
程序中的每个线程将分配到一个处理核上，因此可以同时运行。

###### 知识点
线程并发与线程安全
- 线程安全性
  - 原子性，可见性，有序性，atomic包，CAS算法，synchorized, Lock
    ,voliate, happes-before
- 安全发布对象
  - 安全发布方法，不可变对象，final关键字，不可变方法，线程不安全写法
- 线程封闭，同步容器，并发容器
  - 堆栈封闭，ThreadLocal, JDBC 线程封闭，同步容器，并发容器，JUC
- AQS, JUC
- 线程调度
  - 线程池，new Thread 弊端， ThreadExecutor, Executor框架接口
- 线程安全补充内容
##### 高并发
 High Concurrency 是互联网分布式系统架构设计中必须考虑的因素之一，定义：
通过设计保证系统能够**同时并行处理**很多请求。

并发： 多个线程操作相同的资源，保证线程安全，合理使用资源
高并发： 服务器同时处理很多请求，提供高性能

### 1-5 JAVA 内存模型 JMM
**规定了一个线程如何和何时看到其他线程修改过后的共享变量的值，以及在必须时，如何同步的访问共享变量**
![avator](https://img0.baidu.com/it/u=660268947,3288773061&fm=26&fmt=auto&gp=0.jpg)
Stack:
- method
  - int,short,byte...
  - local variable,could be a reference
    
- 存放在寄存器中，访问速度快；共享；数据大小以及生存周期必须是确定的
  缺乏灵活性。
- 
Heap
- Object
- 运行时，动态分配内存；访问时间有点慢；java
垃圾管，负责回收。
  
两个线程可以同时访问一个对象，那么他们都可以访问这个对象的成员变量。
但是 每个线程都有了成员变量的私有拷贝。

cpu registers:  
   - cpu 寄存器， 访问速度很高
cpu Cache Memory 
     - 高速缓存：为了弥补上下两者的运算速度，快于下者，慢于上者。
RAM - Main Memory
 - 内存很大，可以存储 很多东西

#### Java 内存模型抽象结构图
![avator](https://img-blog.csdn.net/20160803203207146)

共享变量副本： 私有拷贝
线程间通信： 必须经过主内存，A 先将变量刷新到主内存，B再从主内存获取变量的值。

#### java 内存模型-同步八种操作
- lock: 作用于 *主内存* 的变量，把一个变量标识为一条线程独占状态
- unlock: 作用于 *主内存* 的变量，把一个处于锁定状态的变量释放出来，
  释放后的变量才可以被其他线程锁定
- read:作用于 *主内存* 的变量，把一个变量值从主内存传输到线程的工作内存中
  ，以便随后的load 动作使用
- load: 作用于 *工作内存* 的变量，它把主内存中得到的变量值放入工作内存
的变量副本中。
  
- use: 作用于 *工作内存* 的变量，把工作内存中的一个变量值传递给执行引擎
- assign: 作用于 *工作内存* 的变量，把一个从执行引擎接收到的值，赋值给工作内存的
变量
- store: 作用于 *工作内存* 的变量，把工作内存中的一个变量值，传递到柱内存中，以便后面的write
操作
  
- write: 作用于 *主内存* 的变量，它把store操作从工作内存中一个变量的值
传送到主内存的变量中
  
![avator](https://img-blog.csdnimg.cn/img_convert/979e5cf0d6fee5619a92b14ba75f8650.png)


#### java 内存模型-同步规则
- 如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load
操作，如果把变量从工作内存同步到主内存中，就要按顺序地执行store和write操作。
  但java内存模型要求上述操作必须按照顺序执行，而没有保证必须时连续执行
  
- 不允许read和load,store,write操作之一单独出现
- 不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中
改变了之后必须同步到主内存中
  
- 不允许一个线程无原因地（没有发生任何assign操作）把数据从工作内存中
同步到主内存中
  
- 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个
未被初始化（load ,assign）的变量。即就是对一个变量实施use,store之前，
  必须执行过assign 和load 操作
  
- 一个变量在同一个时刻只允许**一条线程**对其进行Lock操作，但lock
操作可以被同一条线程重复执行很多次，多次执行lock后，只有执行相同次数
  的unlock操作，变量才能被解锁。lock和unlock必须成对出现
  
- 如果对一个变量执行Lock操作，将会清空工作内存中此变量的值，在执行
引擎使用这个变量前，需重新执行load或assign 操作初始化变量值。
  
- 如果一个变量事先没有被Lock操作锁定，则不允许对它执行Unlock操作；
也不允许去Unlock一个被其他线程锁定的变量
  
- 对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行
  store和write操作）
  
### 并发编程与线程安全  

  
### Reference
##### 异步 与同步
同步： 发送一个请求，需要等待返回，然后才能发送下一个请求，有个等待过程
异步： 发送一个请求，不需要等待返回，随时可以发送另一个请求。
区别： 一个需要等待，一个不需要 等待。在绝大多数的项目中不需要异步交互
异步不安全，容易造成死锁。但没有同步机制存在，读写效率会高很多。

分析： 1，同步和异步的对象是谁？
线程。不同的线程之间进行同步和异步。如果线程同步，那么线程之间访问同一个
资源的时候，就需要等待。即，有一个线程是处于等待时机的。
2， 访问同一对象资源的时候为什么需要这些概念？或者说，是为了应付哪种问题呢？
因为对同一个文件的读写，会影响其他的线程读写，导致读的值不是最新的值。写进去被覆盖等。

##### 信号量
Semaphore 是一个线程同步结构，用于线程间传递信号，以避免出现信号丢失，或者像
锁一样用于保护关键区域。

Semaphore 可以控制某个资源被访问的次数，通过 `acquire()` 获取一个许可，
通过 `release()` 释放一个许可。比如在windows 下可以设置共享文件的最大访问数量。

###### 模型
一个计数器，一个等待列队，三个方法（ `init` `down` `up` ）
- init  设置计数器初始值
- down 计数器减1 操作
- up  计数器加1  操作
以上均是原子操作。在JDK 并发包中，up 和 down 分别对应acquire
 和 release 方法。
[信号量简明介绍](https://blog.csdn.net/ds19980228/article/details/89094882)

[信号量1](ifeve.com/semaphore/)

##### 私有拷贝
